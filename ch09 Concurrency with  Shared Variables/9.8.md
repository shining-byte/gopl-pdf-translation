### 9.8 协程与线程
在之前的章节中，我们提到可以暂时忽略协程（goroutine）和操作系统（OS）线程之间的差异。尽管它们的区别本质上是数量级的，但当数量级差异足够大时，就会演变为质的差异——协程与线程的关系正是如此。现在，我们有必要明确区分它们。

#### 9.8.1 可扩展的栈
每个操作系统线程都有一个固定大小的内存块（通常为2MB）作为栈空间，用于存储正在执行或临时挂起的函数调用的局部变量。这种固定大小的栈既可能浪费内存，也可能不够用：
- 浪费内存：对于简单的协程（例如仅等待WaitGroup或关闭通道的协程），2MB的栈是巨大的浪费。Go程序常需一次性创建数十万个协程，若每个协程占用2MB栈，内存将无法承受。
- 不足风险：固定大小的栈对某些复杂或深度递归的函数可能不够用。调整栈大小可以提升空间效率（支持更多线程）或支持更深递归，但无法同时兼顾。

相比之下，协程的栈初始仅约2KB，但会按需动态伸缩（最大可达1GB，远超过典型线程栈）。不过实际中极少协程需要如此大的栈。

练习9.4：构建一个由任意数量协程通过通道连接的流水线。在不耗尽内存的情况下，最多能创建多少级流水线？一个值通过整个流水线需要多长时间？

#### 9.8.2 协程调度
操作系统线程由内核调度：
1. 硬件中断触发调度：每毫秒级的时间片，处理器被硬件中断触发内核调度器，暂停当前线程并保存其寄存器状态，再从线程列表中选出下一个待运行线程，恢复其寄存器状态并执行。
2. 上下文切换成本高：线程切换需完整保存和恢复状态（上下文切换），涉及大量内存访问和调度器数据结构的更新。由于局部性差和内存访问延迟，这种操作历来较慢，且随着CPU访问内存所需周期数的增加而愈发严重。

Go 运行时（Goruntime）内置了自己的调度器，采用 m:n 调度技术，即在 n 个操作系统线程 上调度 m 个协程。Go 调度器的职责类似于内核调度器，但仅针对单个 Go 程序内的协程。与操作系统线程调度器不同，Go 调度器并非由硬件定时器周期性触发，而是通过某些 Go 语言结构隐式调用。例如：
- 当协程调用 time.Sleep、因通道或互斥锁操作阻塞时，调度器会将其休眠并运行另一个协程，直到唤醒条件满足。
- 优势：由于无需切换到内核上下文，重新调度协程的成本远低于线程切换。

练习 9.5：编写一个程序，启动两个协程通过无缓冲通道以“乒乓”方式互相传递消息。该程序每秒能支持多少次通信？

#### 9.8.3 GOMAXPROCS
Go 调度器通过 GOMAXPROCS 参数决定同时执行 Go 代码的操作系统线程数：
- 默认值：机器 CPU 核数（例如 8 核机器默认启用 8 个线程，对应 m:n 调度中的 n）。
- 例外：休眠或通信阻塞的协程无需占用线程；但涉及系统调用或非 Go 代码的阻塞操作仍需线程，此类线程不计入 GOMAXPROCS。

可通过环境变量或 runtime.GOMAXPROCS() 函数显式控制该参数。例如以下程序无限打印 0 和 1：

```go 
for {     
    go fmt.Print(0)     
    fmt.Print(1) 
} 
```

运行效果：
```bash 
$ GOMAXPROCS=1 go run hacker-cliché.go  
111111111111111111110000000000000000000011111...  # 协程轮流执行 
$ GOMAXPROCS=2 go run hacker-cliché.go  
010101010101010101011001100101011010010100110...  # 协程并行执行
``` 
- GOMAXPROCS=1：主协程打印 1，调度器间歇切换至打印 0 的协程。
- GOMAXPROCS=2：两个线程并行执行协程，输出混合更均匀。

需注意，协程调度受多种因素影响，且运行时持续优化，实际结果可能与示例不同。


#### 练习 9.6：计算密集型并行程序的性能与 GOMAXPROCS 的关系
（参考练习 8.5）测量计算密集型并行程序在不同 GOMAXPROCS 值下的性能表现。在您的计算机上，最优值是多少？您的计算机有多少个 CPU？

实验建议：
1. 编写一个计算密集型任务（如素数计算、矩阵乘法）。
2. 使用 runtime.GOMAXPROCS() 动态调整线程数（从 1 到 CPU 核心数）。
3. 通过 time 包测量执行时间，绘制性能随 GOMAXPROCS 变化的曲线。
4. 使用 runtime.NumCPU() 获取机器 CPU 核心数。

示例代码框架：
```go 
func compute() {     // 计算密集型任务 
}  
func main() {     
    for p := 1; p <= runtime.NumCPU(); p++ {         
        runtime.GOMAXPROCS(p)         
        start := time.Now()         
        var wg sync.WaitGroup         
        for i := 0; i < 100; i++ {             
            wg.Add(1)             
            go func() { 
                compute(); 
                wg.Done() 
                }()         
        }         
        wg.Wait()         
        fmt.Printf("GOMAXPROCS=%d: %v\n", p, time.Since(start))     
    } 
} 
```
#### 9.8.4 协程无身份标识
大多数支持多线程的系统或语言中，线程具有明确的身份标识（如整数 ID 或指针），这便于实现线程本地存储（TLS）——一种以线程 ID 为键的全局存储，使各线程能独立存取数据。

Go 的设计选择：
- 协程无暴露给程序员的身份标识：刻意避免 TLS 的滥用模式。
- 问题背景：在依赖 TLS 的 Web 服务器中，常见通过线程标识隐式传递 HTTP 请求上下文，导致函数行为不仅依赖参数，还隐式依赖线程身份。若线程池动态调整（如某些工作线程被复用），可能引发难以调试的异常。
- Go 的哲学：通过显式参数传递所有影响行为的输入，使代码更清晰且易于并发拆分。例如：
```go   
// 显式传递请求上下文，而非依赖协程身份   
func handleRequest(ctx Context, req *Request) {       
    // 逻辑清晰，可安全跨协程调度   
    }   
```
#### 后续内容预告
至此，您已掌握 Go 语言的全部核心特性。接下来两章将探讨大型工程实践：
1. 项目结构：如何将项目组织为包集合。
2. 工具链：包的获取、构建、测试、基准测试、性能分析、文档化及共享方法。
