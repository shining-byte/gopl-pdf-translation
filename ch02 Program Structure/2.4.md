### 2.4 赋值

通过赋值语句可以更新变量的值，其基本形式是在`=`左侧放置变量，右侧放置表达式：

```go
x = 1               // 命名变量赋值
*p = true           // 通过指针间接赋值
person.name = "bob" // 结构体字段赋值
count[x] = count[x] * scale  // 数组/切片/map元素赋值
```

#### 赋值操作符简化

每个算术运算符和位运算符都有对应的复合赋值运算符。例如最后一条语句可以简化为：

```go
count[x] *= scale  // 等价于 count[x] = count[x] * scale
```

这种方式避免了重复书写（和重复计算）变量表达式。

#### 自增/自减运算

数值变量支持`++`和`--`操作：

```go
v := 1
v++    // 等价于 v = v + 1，v 变为 2
v--    // 等价于 v = v - 1，v 变回 1
```

注意事项：

1. Go语言中`++`/`--`是语句而非表达式
2. 不支持前缀形式（如`++v`）和赋值时使用（如`x = v++`）

### 2.4.1 元组赋值

元组赋值（tuple assignment）允许同时为多个变量赋值。其核心特性是：**右侧所有表达式会先完成求值**，然后再更新左侧变量。这种特性使得元组赋值特别适用于以下场景：

#### 典型应用场景

1. **变量值交换**  

```go
x, y = y, x                    // 交换两个变量的值
a[i], a[j] = a[j], a[i]        // 交换数组元素
```

2. **数学计算**  

```go
// 计算最大公约数(GCD)
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y  // 同步更新x和y
    }
    return x
}

// 计算第n个斐波那契数
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y  // 同步更新数列值
    }
    return x
}
```

3. **批量简单赋值**  

```go
i, j, k = 2, 3, 5  // 同时初始化多个变量
```

#### 使用建议

- **简单赋值**：元组形式可使代码更紧凑  
- **复杂表达式**：建议拆分为多个独立语句（增强可读性）

#### 多返回值处理

当函数返回多个值时，左侧变量数必须与返回值数量匹配：

```go
f, err = os.Open("foo.txt")  // os.Open返回两个值
```

常见惯例：

- 第二个返回值通常表示操作状态：
  - `error`类型（如`os.Open`）
  - 布尔类型（通常命名为`ok`）

#### 特殊操作符的多值返回

后续章节将会介绍，以下三种操作在赋值语句中需要接收两个返回值时，都会额外产生一个布尔型结果：

```go
v, ok = m[key]     // map查询（§4.3）
v, ok = x.(T)      // 类型断言（§7.10）
v, ok = <-ch       // 通道接收（§8.4.2）
```

#### 空白标识符用法

与变量声明类似，可使用下划线 `_` 忽略不需要的返回值：

```go
_, err = io.Copy(dst, src)  // 丢弃拷贝的字节数，仅保留错误信息
_, ok = x.(T)              // 仅检查类型是否匹配，丢弃实际值
```

#### 多返回值处理机制

1. **map查询**  
   - 当key不存在时：`ok`返回`false`，`v`返回value类型的零值

2. **类型断言**  
   - 断言失败时：`ok`返回`false`，`v`返回类型T的零值

3. **通道接收**  
   - 当通道已关闭时：`ok`返回`false`，`v`返回通道元素类型的零值

### 2.4.2 可赋值性

赋值语句是显式的赋值形式，但程序中还存在许多隐式赋值的场景：

- 函数调用时，实参会隐式赋给形参变量

- `return`语句会将返回操作数隐式赋给结果变量

- 复合类型（§4.2）的字面量表达式会执行隐式元素赋值，例如：

  ```go
  medals := []string{"gold", "silver", "bronze"}
  ```

  其实际效果等同于：

  ```go
  medals[0] = "gold"
  medals[1] = "silver"
  medals[2] = "bronze"
  ```

  （map和通道的元素虽不是普通变量，也遵循类似的隐式赋值规则）

#### 可赋值性规则

当满足以下条件时，赋值操作（显式或隐式）才是合法的：

1. **基础规则**  
   - 左值（变量）与右值（值）类型必须完全匹配
   - `nil`可赋给任何接口类型或引用类型（如指针、切片、map等）

2. **常量特例**（§3.6）  
   - 常量具有更灵活的可赋值规则，通常不需要显式类型转换

3. **比较操作关联规则**  
   - 使用`==`和`!=`比较时，要求其中一个操作数必须可赋给另一个操作数的类型
   - 每种新类型引入时都会说明其特定的可比性规则
