## 1.2 命令行参数

大多数程序都需要处理输入数据并产生输出结果，这几乎是计算的基本定义。但程序如何获取需要处理的输入数据呢？有些程序会自行生成数据，但更多情况下，输入数据来自外部来源：文件、网络连接、其他程序的输出、键盘输入的用户指令、命令行参数等。接下来的几个示例将讨论这些输入方式，首先从命令行参数开始。

os包以跨平台的方式提供了与操作系统交互的函数和变量。在Go程序中，可以通过os包中的Args变量来获取命令行参数。在os包外部引用这个变量时，需要使用os.Args这个完整名称。

os.Args是一个字符串切片（slice）。切片是Go语言中的核心概念，我们稍后会详细讨论。现在可以简单地将切片理解为一个动态大小的数组序列，可以通过s[i]访问单个元素，通过s[m:n]访问连续的子序列。切片的长度由len(s)给出。与大多数编程语言一样，Go的索引也采用左闭右开区间，即包含起始索引但不包含结束索引，这样的设计可以简化逻辑处理。例如，切片s[m:n]（其中0 ≤ m ≤ n ≤ len(s)）包含n-m个元素。

在os.Args中，第一个元素os.Args[0]是命令本身的名称，其余元素则是程序启动时传入的参数。切片表达式s[m:n]会返回从m到n-1的元素组成的切片，因此我们需要的参数可以通过os.Args[1:len(os.Args)]获取。如果省略m或n，默认值分别为0和len(s)，所以我们可以简写为os.Args[1:]。



这是一个Unix echo命令的实现，它会将命令行参数打印在一行中。程序导入了两个包，采用括号包裹的列表形式而非单独的import声明。两种形式都合法，但约定俗成使用列表形式。import的顺序无关紧要，gofmt工具会自动按字母顺序排序包名。（当示例有多个版本时，我们通常会编号以便明确所指。）

gopl.io/ch1/echo1

```go
// Echo1打印其命令行参数
package main

import (
"fmt"
"os"
)

func main() {
    var s, sep string
    for i := 1; i < len(os.Args); i++ {
        s += sep + os.Args[i]
        sep = " "
    }
    fmt.Println(s)
}
```

注释以//开头。从//到行尾的所有文本都是给程序员看的注释内容，编译器会忽略它们。按照惯例，我们会在包声明前立即用注释描述该包；对于main包，这个注释应该是一个或多个完整句子来描述整个程序。

var声明定义了两个string类型的变量s和sep。变量可以在声明时初始化。如果没有显式初始化，变量会被隐式初始化为其类型的零值——数值类型为0，字符串类型为""。因此在这个例子中，声明隐式地将s和sep初始化为空字符串。我们将在第2章更详细地讨论变量和声明。

在数值运算方面，Go语言提供了常见的算术和逻辑运算符。但当+运算符作用于字符串时，它执行的是字符串连接操作。因此表达式sep + os.Args[i]表示将字符串sep和os.Args[i]连接起来。程序中使用的语句：

```go 
s += sep + os.Args[i] 
```



这是一个赋值语句，它将s的旧值与sep和os.Args[i]连接后重新赋值给s，等价于：

```go
 s = s + sep + os.Args[i] 
```

+=是一个复合赋值运算符。每个算术和逻辑运算符（如+或*）都有对应的复合赋值运算符。

echo程序本可以每次循环打印一部分输出，但这个版本选择通过不断追加新文本来构建完整字符串。字符串s初始为空（即值为""），每次循环都会添加新内容：第一次迭代后会额外插入一个空格，确保最终每个参数间都有一个空格分隔。虽然这种二次方级操作在参数很多时可能效率较低，但对echo程序来说影响不大。本章和下一章我们将展示echo的多个改进版本来解决可能的效率问题。

循环索引变量i在for循环的第一部分声明。:=是短变量声明语法的一部分，它可以声明一个或多个变量并根据初始值自动推断类型（下一章会详细介绍）。

自增语句i++将i加1，等价于i += 1，也等价于i = i + 1。对应的自减语句是i--。需要注意的是，这些是语句而非表达式（与C家族语言不同），因此j = i++是非法的，而且只支持后缀形式，--i也是非法的。

for循环是Go语言中唯一的循环语句，它有多种形式，这里展示的是其中一种：

```go
for initialization; condition; post {
    // 零个或多个语句
}
```



for循环的三个组成部分不需要括号包裹，但大括号是必须的，且左大括号必须与post语句在同一行。可选的initialization语句在循环开始前执行，它必须是简单语句（短变量声明、自增/赋值语句或函数调用）。condition是一个布尔表达式，在每次循环开始时求值，若为true则执行循环体。post语句在循环体执行后运行，然后再次检查condition。当condition为false时循环终止。



for循环的三个部分（初始化、条件判断、后置操作）都可以省略。如果省略初始化和后置语句，分号也可以省略，这样就变成了传统的"while"循环形式：

```go
for condition {     // ... } 
```



如果完全省略条件判断，例如：

```go
 for {     // ... } 
```



这将创建一个无限循环，不过这种循环通常需要通过其他方式终止（如break或return语句）。

for循环还有另一种形式，可以遍历字符串或切片等数据类型的值范围。下面展示echo程序的第二个版本：

gopl.io/ch1/echo2

```go 
// Echo2打印其命令行参数
package main

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "", ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}
```



在每次循环迭代中，range会产生一对值：当前元素的索引和对应的值。在这个例子中我们不需要索引，但range循环的语法要求如果要处理元素值就必须同时处理索引。理论上可以将索引赋给一个临时变量（如temp）然后忽略它，但Go不允许存在未使用的局部变量，这会导致编译错误。

解决方案是使用空白标识符_（下划线）。当语法需要变量名但程序逻辑不需要时（比如我们只需要元素值而想丢弃索引时），就可以使用空白标识符。大多数Go程序员都会选择使用range和_来编写上面的echo程序，因为这种方式隐式处理os.Args的索引，比显式索引更不容易出错。



这个版本的echo程序使用短变量声明来同时声明和初始化s与sep变量，但其实也可以分开声明。Go语言中有多种声明字符串变量的方式，以下四种写法完全等效：

```go 
s := "" var s string var s = ""  var s string = "" 
```



如何选择声明形式？第一种短变量声明形式最为简洁，但只能用在函数内部，不能用于包级变量。第二种形式依赖字符串的零值（""）进行默认初始化。第三种形式除非同时声明多个变量，否则很少使用。第四种形式显式指定了变量类型，当类型与初始值相同时显得冗余，但在类型不一致时是必需的。实践中通常建议使用前两种形式：当初始值重要时使用显式初始化，当初始值无关紧要时使用隐式初始化。

如前所述，每次循环都会完全重建字符串s。+=语句通过连接旧字符串、空格和下一个参数来创建新字符串，然后赋值给s。旧字符串内容不再被引用，将由垃圾收集器适时回收。当处理大量数据时，这种操作可能效率较低。

更简单高效的解决方案是使用strings包中的Join函数：

gopl.io/ch1/echo3

```go

func main() {
    fmt.Println(strings.Join(os.Args[1:], " "))
}
```



如果不需要特定格式，只关注变量值（比如调试时），可以直接用Println格式化输出：

```go 
fmt.Println(os.Args[1:])  
```

这种输出结果与strings.Join类似，但会带有方括号。任何切片都可以这样打印。

练习：
1.1 修改echo程序，使其同时打印os.Args[0]（即被调用的命令名称）
1.2 修改echo程序，使每个参数的索引和值单独成行打印
1.3 对比测试低效版本与strings.Join版本的运行时间差异（1.6节介绍time包的部分功能，11.4节讲解如何编写系统化的性能基准测试）